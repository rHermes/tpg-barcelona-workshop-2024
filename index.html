<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css" />
  <link rel="stylesheet" href="dist/reveal.css" />
  <link rel="stylesheet" href="dist/theme/black.css" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/base16/solarized-light.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>C++ Workshop Barcelona 2024</h1>
        <p>Presentert av Teodor Sp칝ren</p>
      </section>

      <section>
        <h1>Gj칮r c++ enklere</h1>
        <q>Within C++, there is a much smaller and cleaner language struggling
          to get out</q>
        <p>Bjarne Stroustrup</p>

        <aside class="notes">
          M친let med talken er 친 gi noen innsikt i ting dere kan ta med hjem og
          bruke til 친 gj칮re koden deres enklere. Derfor vil noen av tingene
          v칝re veldig surface level, for 친 gi dere nok info til 친 vite om dere
          trenger 친 bruke mer energi p친 dette.
        </aside>
      </section>

      <section>
        <h2>Innhold</h2>
        <ul>
          <li>Sm친 tips og triks</li>
          <li>游댠Lambdaer游댠</li>
          <li>游댠Concepts游댠</li>
          <li>Ranges</li>
          <li><code>std::string_view</code></li>
          <li>Memory managment 游</li>
          <li>Ting som gj칮r livet vansklig</li>
          <li>Optimalisering (hvis vi rekker...)</li>
        </ul>
        <aside class="notes">
          Det er mye p친 tapetet her, s친 jeg pr칮ver 친 putte de tingene som er
          mest brukbare f칮rst og om vi g친r tom for tid s친 er det greit! Vi
          starter med bare litt div tips som dere kan ta rett med dere p친
          jobben
        </aside>
      </section>

      <section>
        <h1>Sm친 tips og triks</h1>

        <aside class="notes">
          Noe som er viktig 친 p친peke her, er at n친r jeg sp칮r dere f칮r hvert
          triks om dere kan det, s친 er det ikke noe lure sp칮rsm친l. Dette er
          ment som en referanse senere ogs친, s친 om vi alle kan trikset, s친 g친r
          vi bare videre! Mer en nok innhold!
        </aside>
      </section>

      <section>
        <section>
          <p><code>std::unordered_(map|set)</code></p>
          <pre><code data-trim class="language-cpp"><script type="text/template">
            std::map<int, std::string> dict;
            std::set<int> seen;
          </script></code></pre>
          <p>VS</p>
          <pre><code data-trim class="language-cpp"><script type="text/template">
            std::unordered_map<int, std::string> dict;
            std::unordered_set<int> seen;
          </script></code></pre>
        </section>

        <section>
          <p><code>std::unordered_(map|set)</code></p>
          <ul>
            <li>
              Nesten drop in versjoner av <code>std::set</code> og
              <code>std::map</code>
            </li>
            <li>Som regel mye raskere</li>
            <li>Krever at n칮kkelen kan hashes</li>
            <li>B칮r v칝re deres default</li>
          </ul>
        </section>
      </section>

      <!-- Structured bindings-->
      <section>
        <section>
          <h1>Structured bindings</h1>
        </section>

        <section data-auto-animate>
          <p>Har du v칝rt her?</p>
          <pre data-id="wow"><code data-trim class="language-cpp"  data-line-numbers="|1-3|6-7"><script type="text/template">
            std::pair<int,int> getPair() {
                return {1, 2};
            }

            int main() {
                auto pp = getPair();
                std::cout << pp.first + pp.second << "\n";
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <p>Du kan v칝re her!</p>
          <pre data-id="wow"><code data-trim class="language-cpp" data-line-numbers="6-7"><script type="text/template">
            std::pair<int,int> getPair() {
                return {1, 2};
            }

            int main() {
                auto [a, b] = getPair();
                std::cout << (a + b) << "\n";
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <p>Eller enda verre, har du v칝rt her?</p>
          <pre data-id="wow2" data-noescape><code data-trim class="language-cpp"  data-line-numbers="|1-3|6-7"><script type="text/template">
            std::tuple<int,int,int> getTuple() {
                return {1, 2, 3};
            }

            int main() {
                const auto pp = getTuple();
                std::cout << std::get<0>(pp) + std::get<2>(pp) << "\n";
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <p>Du kan v칝re her!</p>
          <pre data-id="wow2"><code data-trim class="language-cpp" data-line-numbers="6-7"><script type="text/template">
            std::tuple<int,int,int> getTuple() {
                return {1, 2, 3};
            }

            int main() {
                const auto [a, _, c] = getTuple();
                std::cout << a + c << "\n";
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <p>N친 ogs친 for maps:</p>
          <pre data-id="wow3"><code data-trim class="language-cpp" data-line-numbers="|2-6|8-11"><script type="text/template">
            int main() {
                std::unordered_map<int,std::string> dict{
                    {1, "World"},
                    {2, "Hey!"},
                    {3, "Tpg"},
                };

                for (const auto kv : dict) {
                    std::cout << "Key: " << kv.first;
                    std::cout << ", value = " << kv.second << "\n";
                }
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <p>N친 ogs친 for maps:</p>
          <pre data-id="wow3"><code data-trim class="language-cpp" data-line-numbers="8-11"><script type="text/template">
            int main() {
                std::unordered_map<int,std::string> dict{
                    {1, "World"},
                    {2, "Hey!"},
                    {3, "Tpg"},
                };

                for (const auto& [id, value] : dict) {
                    std::cout << "Key: " << id;
                    std::cout << ", value = " << value << "\n";
                }
            }
          </script></code></pre>
        </section>

        <section>
          <h3>Flere alternativer</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|6"><script type="text/template">
            std::tuple<int,int,int> getTuple() {
                return {1, 2, 3};
            }

                  auto  [a, b, c] = getTuple(); // #1
                  auto& [a, b, c] = getTuple(); // #2 (This will error!)
            const auto  [a, b, c] = getTuple(); // #3
            const auto& [a, b, c] = getTuple(); // #4
          </script></code></pre>
        </section>
      </section>

      <!-- If variabler -->
      <section>
        <section data-auto-animate>
          <h2><code>if</code> variabler</h2>
          <pre data-id="wow"><code data-trim class="language-cpp" data-line-numbers="|2|4-7"><script type="text/template">
            std::string getAnswer(int x) {
                static std::unordered_map<int, std::string> cache;

                auto it = cache.find(x);
                if (it != cache.end()) {
                    return it->second;
                }

                // Some other function, not important.
                auto ans = computeAnswer(x);

                cache.emplace(x, ans);
                return ans;
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <h2><code>if</code> variabler</h2>
          <pre data-id="wow"><code data-id="wow" data-trim class="language-cpp" data-line-numbers="4-6"><script type="text/template">
            std::string getAnswer(int x) {
                static std::unordered_map<int, std::string> cache;

                if (auto it = cache.find(x); it != cache.end()) {
                    return it->second;
                }

                // Some other function, not important.
                auto ans = computeAnswer(x);

                cache.emplace(x, ans);
                return ans;
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <h2><code>if</code> variabler</h2>
          <pre data-id="wow"><code data-id="wow" data-trim class="language-cpp"><script type="text/template">
              if (auto it = cache.find(x); it != cache.end()) {
                  return it->second;
              }
            </script></code></pre>
          <ul>
            <li>Scoper variablet</li>
            <li>Nyttig for mye brukte navn</li>
            <li>Tidligere destruction</li>
          </ul>
        </section>

        <section>
          <h3>Annet eksempel</h3>
          <pre><code data-id="wow" data-trim class="language-cpp"><script type="text/template">
            std::unordered_map<int, int> seen;

            // Insert or max.
            if (auto [it, inserted] = cache.emplace(x, y); !inserted) {
                it->second = std::max(it->second, y);
            }
          </script></code></pre>
        </section>
      </section>

      <!-- Emplace funksjoner -->
      <section>
        <section>
          <h2><code>emplace funksjoner</code></h2>
          <pre><code data-trim class="language-cpp"><script type="text/template">
                        std::vector<std::pair<int,int>> points;

                        points.push_back({1, 3});
                        points.push_back({13, 8});
                    </script></code></pre>
          <p>VS</p>
          <pre><code data-trim class="language-cpp"><script type="text/template">
              std::vector<std::pair<int,int>> points;

              points.emplace_back(1, 3);
              points.emplace_back(13, 8);
          </script></code></pre>
        </section>

        <section>
          <h3>Hvorfor?</h3>
          <ul>
            <li>Bedre syntax</li>
            <li>Unng친r moves</li>
            <li>Conditional moves for map!</li>
          </ul>
        </section>

        <section>
          <h3>Hva st칮tter dette?</h3>
          <p>Alle standard bibliotek containere!</p>
        </section>

        <!--
                <section>
                    <h2><code>std::map_*</code></h2>
                    <pre><code data-trim class="language-cpp"><script type="text/template">
                        std::map<int, int> dict;

                        dict.insert({1, 3});
                    </script></code></pre>
                    <p>VS</p>
                    <pre><code data-trim class="language-cpp"><script type="text/template">
                        std::map<int, int> dict;

                        dict.emplace(1, 3);
                    </script></code></pre>
                </section>

            -->
        <section data-auto-animate>
          <h3>Conditional moves</h3>
          <p>Her har vi et problem:</p>
          <pre data-id="wow4"><code data-trim class="language-cpp" data-line-numbers="|1|3-5|7-13"><script type="text/template">
              std::map<int, std::unique_ptr<std::string>> dict;

              // All good, Q is in a valid, but unspecified state.
              auto Q = std::make_unique<std::string>("Hello");
              dict.emplace(1, std::move(Q));
  
              auto P = std::make_unique<std::string>("World");
              auto [it, inserted] = dict.emplace(1, std::move(P));
              if (inserted) {
                  // If we got it inserted, all good, P has a new home :)
              } else {
                  // We didn't manage to insert, but P is now lost!
              }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <h3>Conditional moves</h3>
          <p>Her har vi et problem:</p>
          <pre data-id="wow4"><code data-trim class="language-cpp" data-line-numbers="7-13"><script type="text/template">
            std::map<int, std::unique_ptr<std::string>> dict;

            // All good, Q is in a valid, but unspecified state.
            auto Q = std::make_unique<std::string>("Hello");
            dict.emplace(1, std::move(Q));

            auto P = std::make_unique<std::string>("World");
            auto [it, inserted] = dict.try_emplace(1, std::move(P));
            if (inserted) {
                // If we got it inserted, all good, P has a new home :)
            } else {
                // We didn't manage to insert it, P was not moved!
            }
          </script></code></pre>
        </section>

        <section>
          <h3>Gotchas!</h3>
          <p>Initializer lists har andre prioriteringer</p>
          <pre><code data-trim class="language-cpp"><script type="text/template">
            std::vector<std::vector<int>> nested;

            nested.push_back({3, 1});   // nested[0] = {3, 1}
            nested.emplace_back(3, 1);  // nested[1] = {1, 1, 1};
            nested.emplace_back({3,1}); // nested[2] = {3, 1};
          </script></code></pre>
        </section>

        <section>
          <h3>Gotchas!</h3>
          <p>Nested pairs</p>
          <pre><code data-trim class="language-cpp"><script type="text/template">
            std::map<double,std::pair<int,int>> dict;

            dict.emplace(std::piecewise_construct,
                         std::forward_as_tuple(1.34),
                         std::forward_as_tuple(2, 3));
            </script></code></pre>
          <p>Og</p>
          <pre><code data-trim class="language-cpp"><script type="text/template">
              std::map<std::pair<int,int>,double> dict;
  
              dict.emplace(std::piecewise_construct,
                           std::forward_as_tuple(2, 3),
                           std::forward_as_tuple(1.34));
            </script></code></pre>
        </section>
      </section>

      <!-- Lambdas -->
      <section>
        <h1>游댠Lambdaer游댠</h1>
      </section>

      <section>
        <h2>Lambdaer</h2>
        <ul>
          <li>Siden C++11</li>
          <li>Anonyme funksjoner, definert inline</li>
          <li>Utrolig nyttige!</li>
          <li>Zero overhead!</li>
          <li>Jeg tenker ofte p친 dem som macroer</li>
        </ul>
      </section>

      <section>
        <section>
          <h3>Lambda syntax - Basics</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1|3|6"><script type="text/template">
            auto funcName = [](int a, int b) {
                std::cout << "Hello: " << a << " and " << b << "\n";
                return a + b + 2;
            };

            int out = funcName(10, 23);
          </script></code></pre>
        </section>

        <section>
          <h3>Lambda syntax - Captures I</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1|2|3|6-8|9-10"><script type="text/template">
            int byRef = 0;
            auto funcName = [&byRef]() {
                std::cout << "ref = " << ++byRef << "\n";
            };

            funcName(); // ref = 1
            funcName(); // ref = 2
            std::cout <<  byRef << "\n"; // Outside = 2
            byRef = 10;
            funcName(); // ref = 11
          </script></code></pre>
        </section>

        <section>
          <h3>Lambda syntax - Captures II</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-2|3|8-10|11-12|13"><script type="text/template">
            int byRef = 0;
            int byVal = 0;
            auto funcName = [&byRef, byVal]() {
                std::cout << "ref = " << ++byRef << ", ";
                std::cout << "val = " << byVal << "\n";
            };

            funcName(); // ref = 1, val = 0
            funcName(); // ref = 2, val = 0
            std::cout <<  byRef << "\n"; // Outside = 2
            byRef = 10;
            byVal = 10;
            funcName(); // ref = 11, val = 0
          </script></code></pre>
        </section>

        <section>
          <h3>Lambda syntax - Captures III</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|3"><script type="text/template">
            int byRef = 0;
            int byVal = 10;
            auto funcName = [&byRef, byVal]() mutable {
                std::cout << "ref = " << ++byRef;
                std::cout << ", val = " << ++byVal << "\n";
            };

            funcName(); // ref = 1, val = 11
            funcName(); // ref = 2, val = 12
            byRef = 10;
            byVal = 100;
            funcName(); // ref = 11, val = 13
          </script></code></pre>
        </section>

        <section>
          <h3>Lambda syntax - Captures IV</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-2|3|8|13-16"><script type="text/template">
            int a = 0;
            int b = 10;
            auto allByRef = [&]() {
                std::cout << "ref a = " << ++a;
                std::cout << ", ref b = " << ++b;
            };

            auto allByVal = [=]() {
              std::cout << "val a = " << a;
              std::cout << ", val b = " << b;
            };

            allByRef();  // ref a = 0, ref b = 11
            allByRef();  // ref a = 1, ref b = 12
            
            allByVal(); // val a = 0, val b = 10
            
          </script></code></pre>
        </section>
      </section>

      <section>
        <section>
          <h3>Noen motiverende eksempler (Noe leetcode)</h3>
          <q>Seeing is believing</q>
        </section>

        <section>
          <h3>Sortere en vector</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-5|7|8-15"><script type="text/template">
            struct Customer {
              std::string name;
              int age;
              int money;
            };

            std::vector<Customer> customers;
            std::ranges::sort(customers, [](const Customer& x,
                                            const Customer& y) {
              if (x.money != y.money) {
                return x.money < y.money;
              }

              return x.name < y.name;
            });

          </script></code></pre>
        </section>

        <section>
          <h3>Sortere en const vector</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-8|10-11|13-22"><script type="text/template">
            struct Customer {
              std::string name;
              int age;
              int money;
            };
            
            // Pretend it's filled with customer data.
            std::vector<Customer> customers;
            
            std::vector<int> indices(customers.size(), 0);
            std::iota(indices.begin(), indices.end(), 0); // 0, 1, 2, ...

            std::ranges::sort(indices, [&](const int i,
                                            const int j) {
              const auto& x = customers[i];
              const auto& y = customers[j];
              if (x.money != y.money) {
                return x.money < y.money;
              }

              return x.name < y.name;
            });
          </script></code></pre>
        </section>

        <section>
          <h3>Custom ordered set</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-5|7-13|13-22"><script type="text/template">
            struct Customer {
              std::string name;
              int age;
              int money;
            };

            const auto sorter = [](const auto& x, const auto& y) {
              if (x.money != y.money) {
                return x.money < y.money;
              }

              return x.name < y.name;
            };
            
            std::set<Customer, decltype(sorter)> customers(sorter);
          </script></code></pre>
        </section>

        <section>
          <h3>Macroer</h3>
          <ul>
            <li>Lambdaer kan capture variabler i en funksjon</li>
            <li>Det kan brukes til mye rart</li>
            <li>Mellom thing mellom: funksjon, klasse og copy paste</li>
          </ul>
          <pre class="fragment"><code class="language-cpp" data-trim><script type="text/template">
            ListNode* head;
            std::vector<std::vector<int>> out(M, std::vector<int>(N, -1));

            const auto writeVal = [&](const int y, const int x) {
                if (head) {
                    out[y][x] = head->val;
                    head = head->next;
                }
            };
            </script></code></pre>
        </section>

        <section>
          <h3>Macroer - Part 1</h3>
          <pre><code class="language-cpp" data-trim><script type="text/template">
              int boxDelivering(
                const std::vector<std::vector<int>>& boxes,
                const int portsCount, const int maxBoxes,
                const int maxWeight) {
            </script></code></pre>
        </section>

        <section>
          <h3>Macroer - Part 2</h3>
          <pre><code class="language-cpp" data-trim><script type="text/template">
          const int N = boxes.size();

          std::vector<int> dp(N+1);

          int sum = 0; // The current weight on the ship.
          int start = 0; // Load all boxes from start to r in one storage
          int diff = 0; // different consecutive ports between start and r
            </script></code></pre>
        </section>

        <section>
          <h3>Macroer - Part 3</h3>
          <pre><code class="language-cpp" data-trim><script type="text/template">
auto samePort = [&](const int idx) {
  if (idx == N-1) {
    return false;
  } else {
    return boxes[idx][0] != boxes[idx+1][0];
  }
};
</script></code></pre>
          <pre><code class="language-cpp" data-trim><script type="text/template">
const auto dropBox = [&] {
  sum -= boxes[start][1];
  diff -= samePort(start);
  start++;
};
</script></code></pre>

          <pre><code class="language-cpp" data-trim><script type="text/template">
const auto addBox = [&](const int idx) {
  if (idx != 0) {
    diff += samePort(idx-1);
  }
  
  sum += boxes[idx][1];
};
</script></code></pre>
        </section>

        <section>
          <h3>Macroer - Part 4</h3>
          <pre><code class="language-cpp" data-trim data-line-numbers="|3-5|7-8|10-13|18-20"><script type="text/template">
for (int r = 0; r < N; r++) {
  // We drop 1 box because of the max boxes constraints.
  if (r-start == maxBoxes) {
    dropBox();
  }

  // We add one more box.
  addBox(r);

  // We keep dropping boxes, while we are overweight.
  while (maxWeight < sum) {
    dropBox();
  }

  // We are loading all packages in [start+1, r].
  // if dp[start] == dp[start+1], the first package can be included in the previous
  // shipment, without cost, and it makes no sense to include it in this one.
  while (start < r && dp[start] == dp[start+1]) {
    dropBox();
  }

  dp[r+1] = diff + 2 + dp[start];
}
          </script></code></pre>
        </section>
      </section>

      <!-- Kanskje legge til skyline problem her -->

      <section>
        <h3>Alt annet dere vil vite, se her:</h3>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/xBAduq0RGes" title="YouTube video player"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
        <p>
          C++ lambda Idioms av Timur Doumler (alt annet han gj칮r er ogs친 bra!)
        </p>
      </section>

      <section>
        <h1>Concepts</h1>
        <p>En bedre m친te 친 begrense template paramtere</p>

        <aside class="notes">
          Vi skal ikke g친 veldig dypt inn i dette. Jeg vil bare gi dere en ide
          om Hva concepts er. Det er mye nytt her og mange ting til og med
          ikke jeg har helt grep p친, men jeg vil vise noen ting.
        </aside>
      </section>

      <section>
        <h3>Motivasjon</h3>
        <ul>
          <li>Bedre feilmeldinger</li>
          <li>bli kvitt <code>std::enable_if</code></li>
          <li>Mindre press p친 function overloading</li>
          <li>Bedre auto completion!</li>
          <li>Compiler speed (Ikke der enda)</li>+
        </ul>
      </section>

      <!--
      <section>
        <section>
          <h3>Bedre feilmeldinger</h3>
          <p><a href="https://godbolt.org/z/sojsaYnTa">Click this</a></p>
        </section>
      </section>
      -->

      <section>
        <section>
          <h3>Eksempel</h3>

          <p>Vi skal lage en enkel tegne api</p>
          <ul>
            <li>Basert p친 친 kalle metoder p친 en type T</li>
            <li>Vi 칮nsker at alle type tegner st칮tter:</li>
            <ul>
              <li><code>size()</code></li>
              <li><code>draw(int, int);</code></li>
              <li><code>clear()</code></li>
            </ul>
            <li>Kunne brukt polymorphism, men ikke alltid mulig.</li>
          </ul>
        </section>

        <section>
          <h3>Display Concept</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-2|4|6|8"><script type="text/template">
            template <typename T>
              concept Display = requires(T a, int i) {
                  // # 1
                  a.clear();
                  // #2
                  a.draw(i, i);
                  // #3
                  { a.size() } -> std::same_as<std::pair<int, int>>;
              };
          </script></code></pre>
        </section>

        <section>
          <h3>Eksempel tegne funksjon</h3>
          <pre><code data-trim class="language-cpp"><script type="text/template">
            template <Display T>
            void drawBorder(T& display) {
                const auto [W, H] = display.size();
            
                for (int x = 0; x < W; x++) {
                    display.draw(x, 0);
                    display.draw(x, H-1);
                }
            
                for (int y = 1; y < H-1; y++) {
                    display.draw(0, y);
                    display.draw(W-1, y);
                }
            }
            </script></code></pre>
        </section>

        <section>
          <h3>Feilmeldinger: gi inn en streng</h3>
          <pre><code data-trim class="language-cpp"><script type="text/template">
            std::string hello;
            drawBorder(hello);
            </script></code></pre>
        </section>
        <section>
          <h3>Bedre feilmeldinger</h3>
          <img class="r-stretch" src="dist/img/display-raw-error.png" />
        </section>
        <section>
          <h3>Bedre feilmeldinger</h3>
          <img class="r-stretch" src="dist/img/display-concept-error.png" />
        </section>
        <section>
          <h3>Bedre feilmeldinger</h3>
          <ul>
            <li>Vi f친r bare ut 1 feil vs alle bruks steder</li>
            <li>Vi f친r melding f칮r expansion skjer</li>
            <li>Feilen sier mer om hva VI m친 gj칮re</li>
          </ul>
        </section>+



        <section>
          <h3>Eksempel Display implementasjon</h3>
          <pre><code data-trim class="language-cpp" data-line-numbers="|1-3|5-15|17-27"><script type="text/template">
              template <int W, int H>
              struct BitScreen {
                  std::bitset<W*H> screen;
              
                  std::pair<int,int> size() const {
                      return {W, H};
                  }
              
                  void draw(int x, int y) {
                      screen.set(y*W + x);
                  }
              
                  void clear() {
                      screen.reset();
                  }
              
                  void print() {
                      for (int y = 0; y < H; y++) {
                          for (int x = 0; x < W; x++) {
                              if (screen[y*W + x])
                                  std::cout << "#";
                              else
                                  std::cout << " ";
                          }
                          std::cout << "\n";
                      }
                  }
              };
            </script></code></pre>
        </section>

        <section>
          <h3>Demo</h3>
          <pre><code data-trim class="language-cpp"><script type="text/template">
              int main() {
                BitScreen<10,5> bt;
                
                drawBorder(bt);
                bt.print();
            
                return 0; 
            }
            </script></code></pre>
          <p>Gir oss:</p>
          <pre><code data-trim>
##########
#        #
#        #
#        #
##########
            </code></pre>
        </section>
      </section>

      <section>
        <section>
          <h3>Litt misc mer</h3>
        </section>

        <section>
          <h3>Mye bra i standard bibliteket</h3>
          <!-- Legg opp liste over metoder.-->
        </section>

        <section>
          <h3>Kombinere konsepter</h3>
          <!-- Vise hvordan man kombinerer concepter-->
        </section>
      </section>

      <!-- Ranges -->
      <section>
        <h1>Ranges</h1>
        <q>This should have been two proposals</q>
      </section>

      <section>
        <h3>Ranges</h3>
        <ul>
          <li>Ranges forslaget la til 2 ting:</li>
          <ul>
            <li>Et <code>range</code> concept</li>
            <li>En haug med views?</li>
          </ul>
          <li>La oss ta en ting av gangen</li>
        </ul>
      </section>

      <section>
        <section>
          <h3>Ranges Conceptene</h3>
          <img src="dist/img/list-of-range-concepts.png" class="r-stretch" />
        </section>

        <section>
          <h3>Ranges Conceptet</h3>
          <pre><code data-trim class="language-cpp"><script type="text/template">
template<class T>
concept range = requires( T& t ) {
    ranges::begin(t); // equality-preserving for forward iterators
    ranges::end (t);
};
          </script></code></pre>
        </section>
      </section>


      <!-- Sl칮yfe diss
      <section>
        <section>
          <h2>Memory managment</h2>
        </section>

      </section>

      <section>
        <h1>Ting som gj칮r livet vansklig</h1>
        <q>C++ is the language of wrong defaults</q>
      </section>

    -->



      <section>
        <h1>Optimalisering</h1>
      </section>

      <section>
        <section data-auto-animate>
          <h3>R친d 1: Bruk <code>.find()</code></h3>
          <p>Hva er problemet et mulig problem her?</p>

          <pre data-id="wow"><code  data-trim class="language-cpp"  data-line-numbers="|4"><script type="text/template">
              std::unordered_map<int, int> lastSensorTemp;

              for (const auto sensorId : sensors) {
                  if (60 < lastSensorTeastSensorTemp[sensorIdmp[sensorId]) {
                      raiseAlarm(sensorId);
                  }
              }
            </script></code></pre>
          <p class="fragment">Om vi ikke har en siste sensor temp s친 lager vi det</p>
        </section>

        <section data-auto-animate>
          <h3>R친d 1: Bruk <code>.find()</code></h3>
          <p>Hva er problemet et mulig problem her?</p>

          <pre  data-id="wow"><code data-trim class="language-cpp"  data-line-numbers="|"><script type="text/template">
              std::unordered_map<int, int> lastSensorTemp;

              for (const auto sensorId : sensors) {
                auto it = lastSensorTemp.find(sensorId);

                if (it != lastSensorTemp && 60 < it->second)
                  raiseAlarm(sensorId);
              }
            </script></code></pre>
          <p>N친 f친r vi den oppf칮rselen vi vil ha</p>
        </section>
      </section>

      <section>
        <section>
          <h3>R친d 2: Forsiktig med
            <code>std::vector&ltbool&gt</code>
          </h3>

          <ul>
            <li>Implementert som et dynamisk bitset</li>
            <li>Har ikke helt lik semantik som andre vektor typer</li>
            <li>Burde het <code>std::dynamic_bitset</code></li>
            <li>Bytt ut med en vector av chars</li>
          </ul>
        </section>
      </section>

      <section>
        <section data-auto-animate>
          <h3>R친d 3: Presize vector</h3>
          <pre data-id="wow"><code  data-trim class="language-cpp" data-line-numbers="|"><script type="text/template">
            std::vector<std::string> navn;

            for (int i = 0; i < N; i++) {
              navn.push_bacK("navn" + std::to_string(i));
            }
          </script></code></pre>
        </section>

        <section data-auto-animate>
          <h3>R친d 3: Presize vector</h3>
          <pre data-id="wow"><code data-trim class="language-cpp"  data-line-numbers="|2"><script type="text/template">
            std::vector<std::string> navn;
            navn.reserve(N);

            for (int i = 0; i < N; i++) {
              navn.push_bacK("navn" + std::to_string(i));
            }
          </script></code></pre>
        </section>
      </section>

      
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,
      slideNumber: "c/t",
      controls: true,
      controlsTutorial: false,
      width: 1400,
      minScale: 0.2,
      maxScale: 3.0,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
    });
  </script>
</body>

</html>